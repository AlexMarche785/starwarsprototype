<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Fighter Sim - Varied TIEs</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }
        body { background-color: #000000; }
        canvas {
            display: block;
            pointer-events: none;
        }
        #info {
            position: absolute;
            top: 50px;
            left: 10px;
            color: white; font-family: sans-serif; background: rgba(0,0,0,0.5);
            padding: 5px; border-radius: 3px; font-size: 12px; z-index: 1;
        }
        #hp-gauge-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 150px;
            height: 20px;
            background-color: rgba(50, 50, 50, 0.7);
            border: 1px solid #777;
            border-radius: 4px;
            overflow: hidden;
            z-index: 1;
            display: flex;
            align-items: center;
        }
        #hp-gauge-bar {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            transition: width 0.2s ease-out, background-color 0.2s ease-out;
        }
        #hp-gauge-text {
            position: absolute;
            left: 5px;
            right: 5px;
            top: 1px;
            color: black;
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(255,255,255,0.5);
            pointer-events: none;
        }

        #game-over-display {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: yellow; font-family: sans-serif; font-size: 32px; font-weight: bold;
            text-align: center; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
            display: none; z-index: 20;
        }

        .touch-control { position: absolute; bottom: 20px; opacity: 0.6; user-select: none; -webkit-user-select: none; touch-action: none; z-index: 10; }
        #joystick-base { left: 20px; width: 120px; height: 120px; background-color: #444; border-radius: 50%; border: 2px solid #222; }
        #joystick-handle { position: absolute; width: 60px; height: 60px; background-color: #888; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #fire-button { right: 20px; width: 80px; height: 80px; background-color: #c00; border-radius: 50%; border: 2px solid #800; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 16px; }
        #fire-button:active { background-color: #800; }
        #warp-button { right: 115px; width: 70px; height: 70px; background-color: #0077cc; border-radius: 50%; border: 2px solid #004488; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 14px; transition: background-color 0.1s ease; }
        #warp-button.active { background-color: #004488; border-color: #002244; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>
    <div id="hp-gauge-container">
        <div id="hp-gauge-bar"></div>
        <span id="hp-gauge-text">HP: 100</span>
    </div>
    <div id="info">Joystick: Pitch/Yaw (Inv) | Fire | Warp Toggle</div>
    <canvas id="gameCanvas"></canvas>
    <div id="game-over-display"></div>

    <div id="joystick-base" class="touch-control"><div id="joystick-handle"></div></div>
    <div id="fire-button" class="touch-control">FIRE</div>
    <div id="warp-button" class="touch-control">WARP</div>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let aircraft, stars, starDestroyer;
        let clock = new THREE.Clock();

        const SPACE_EXTENT = 3000; const NUM_ASTEROIDS = 150; const PLAYER_FIRE_RATE = 0.15;
        const PLAYER_BULLET_SPEED = 300; const PLAYER_BULLET_LIFETIME = 5;
        const ENEMY_BULLET_SPEED = 250;
        const ENEMY_BULLET_LIFETIME = 6; const ENEMY_CANNON_RANGE = 800; const ENEMY_CANNON_FIRE_RATE = 1.5;
        const ENEMY_HIT_CHANCE = 0.05;
        const WING_ANGLE_DEG = 22.5; const NORMAL_THRUST = 80;
        const WARP_THRUST = 500; const NORMAL_FOV = 75; const WARP_FOV = 110; const FOV_LERP_FACTOR = 0.05;
        const DESTROYER_WIN_HITS = 1000;
        const DESTROYER_CANNON_HP = 5; const MAX_YAW_SPEED = Math.PI * 0.6;
        const PLAYER_MAX_HP = 100;

        const NUM_TIE_FIGHTERS = 10;
        const TIE_FIGHTER_HP = 3;
        const TIE_FIGHTER_BASE_SPEED = 45;
        const TIE_FIGHTER_SPEED_VARIATION = 15;
        const TIE_TURN_RATE = Math.PI * 0.6;
        const TIE_PATROL_RADIUS = 400;
        const DESTROYER_DEFENSE_RADIUS = 600;
        const TIE_FIRE_RATE = 1.2;
        const TIE_CANNON_RANGE = 600;
        const TIE_BULLET_SPEED = 280;
        const TIE_AIM_TOLERANCE = 0.95;
        const TIE_HIT_CHANCE = 1.0;
        const TIE_SEPARATION_DISTANCE = 30;
        const TIE_SEPARATION_FORCE = 0.2;

        const EXPLOSION_DURATION = 0.6;
        const EXPLOSION_MAX_SCALE = 20;
        const EXPLOSION_INITIAL_SCALE = 0.5;

        let gameState = 'playing';
        const playerState = { hp: PLAYER_MAX_HP };
        const aircraftState = {
            position: new THREE.Vector3(0, 0, -1500), velocity: new THREE.Vector3(0, 0, 0), rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
            pitchSpeed: 0, rollSpeed: 0, yawSpeed: 0, dragCoefficient: 0.0005, maxRollSpeed: Math.PI * 0.8, maxPitchSpeed: Math.PI * 0.8, maxYawSpeed: MAX_YAW_SPEED,
            controlSensitivity: 0.025, controlDamping: 0.90, isWarping: false
        };
        const uiState = {
            joystickActive: false, joystickIdentifier: null, joystickBaseRect: null, joystickMaxDist: 0,
            fireButtonPressed: false, fireButtonIdentifier: null
        };
        let joystickHandleElement, joystickBaseElement, fireButtonElement, warpButtonElement,
            hpGaugeContainerElement, hpGaugeBarElement, hpGaugeTextElement,
            gameOverDisplayElement;
        let spaceObjects = [];
        let playerBullets = []; let enemyBullets = [];
        let activeExplosions = [];
        let timeSinceLastShot = 0; let fireRequested = false;
        const playerBoundingSphere = new THREE.Sphere(new THREE.Vector3(), 3);

        const explosionGeometry = new THREE.SphereGeometry(1, 16, 12);
        const explosionMaterial = new THREE.MeshBasicMaterial({
            color: 0xffaa33,
            transparent: true,
            opacity: 1.0,
        });

        const pressedKeys = {};

        init();
        animate();

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
            camera = new THREE.PerspectiveCamera(NORMAL_FOV, window.innerWidth / window.innerHeight, 0.1, SPACE_EXTENT * 2);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0x505050, 2); scene.add(ambientLight); const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(100, 50, -200); scene.add(dirLight);
            createStarfield();
            aircraft = createXWing(); aircraft.position.copy(aircraftState.position); aircraft.rotation.copy(aircraftState.rotation); scene.add(aircraft);
            starDestroyer = createStarDestroyer(); spaceObjects.push(starDestroyer); scene.add(starDestroyer);
            spawnTIEFighters(NUM_TIE_FIGHTERS, starDestroyer.position, TIE_PATROL_RADIUS * 1.5);
            populateSpace();

            joystickHandleElement=document.getElementById('joystick-handle'); joystickBaseElement=document.getElementById('joystick-base'); fireButtonElement=document.getElementById('fire-button'); warpButtonElement=document.getElementById('warp-button');
            hpGaugeContainerElement = document.getElementById('hp-gauge-container'); hpGaugeBarElement = document.getElementById('hp-gauge-bar'); hpGaugeTextElement = document.getElementById('hp-gauge-text');
            gameOverDisplayElement = document.getElementById('game-over-display');
            updateHPDisplay();
            setupEventListeners();
        }

        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry(); const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: true }); const starVertices = [];
            for (let i = 0; i < 15000; i++) { const x = (Math.random() - 0.5) * SPACE_EXTENT * 2; const y = (Math.random() - 0.5) * SPACE_EXTENT * 2; const z = (Math.random() - 0.5) * SPACE_EXTENT * 2; if (Math.abs(x) < 200 && Math.abs(y) < 200 && Math.abs(z) < 200) continue; starVertices.push(x, y, z); }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars);
        }
        function createXWing() {
            const aircraftGroup = new THREE.Group(); const greyMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.6, metalness: 0.3 }); const darkGreyMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7, metalness: 0.2 }); const redMat = new THREE.MeshStandardMaterial({ color: 0xAA0000 }); const fuselageGeo = new THREE.CylinderGeometry(0.5, 0.8, 10, 8); const fuselage = new THREE.Mesh(fuselageGeo, greyMat); fuselage.rotation.x = Math.PI / 2; const fuselageRadiusAtCenter = 0.65; aircraftGroup.add(fuselage); const cockpitGeo = new THREE.SphereGeometry(0.8, 8, 6); const cockpit = new THREE.Mesh(cockpitGeo, darkGreyMat); cockpit.position.set(0, 0.6, -3.5); cockpit.scale.z = 1.5; aircraftGroup.add(cockpit); const engineRadius = 0.3; const engineLength = 2; const engineGeo = new THREE.CylinderGeometry(0.4, engineRadius, engineLength, 8); const enginePositions = [ { x: 1.2, y: 0.5, z: 4.5 }, { x: -1.2, y: 0.5, z: 4.5 }, { x: 1.2, y: -0.5, z: 4.5 }, { x: -1.2, y: -0.5, z: 4.5 } ]; aircraftGroup.userData.engineFlames = []; const flameMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8, side: THREE.DoubleSide }); enginePositions.forEach(pos => { const engine = new THREE.Mesh(engineGeo, darkGreyMat); engine.position.set(pos.x, pos.y, pos.z); engine.rotation.x = Math.PI / 2; aircraftGroup.add(engine); const flameLength = 2.5; const flameGeo = new THREE.ConeGeometry(engineRadius * 0.8, flameLength, 8); const flameMesh = new THREE.Mesh(flameGeo, flameMat); flameMesh.position.set(pos.x, pos.y, pos.z + engineLength / 2 + flameLength / 2); flameMesh.rotation.x = Math.PI / 2; flameMesh.visible = false; aircraftGroup.add(flameMesh); aircraftGroup.userData.engineFlames.push(flameMesh); }); const wingWidth = 6; const wingThickness = 0.2; const wingDepth = 2.5; const wingGeo = new THREE.BoxGeometry(wingWidth, wingThickness, wingDepth); const wingAngleRad = THREE.MathUtils.degToRad(WING_ANGLE_DEG); const wingAttachRadius = fuselageRadiusAtCenter * 1.1; const wingYPosition = 0.1; const wingData = [ { attachX: wingAttachRadius, attachY: wingYPosition, side: 1, vertical: 1, ry: -0.1 }, { attachX: -wingAttachRadius, attachY: wingYPosition, side: -1, vertical: 1, ry: 0.1 }, { attachX: wingAttachRadius, attachY: -wingYPosition, side: 1, vertical: -1, ry: -0.1 }, { attachX: -wingAttachRadius, attachY: -wingYPosition, side: -1, vertical: -1, ry: 0.1 } ]; aircraftGroup.userData.cannonOffsets = []; wingData.forEach(data => { const wingPivotGroup = new THREE.Group(); wingPivotGroup.position.set(data.attachX, data.attachY, 0); const wingMesh = new THREE.Mesh(wingGeo, greyMat); wingMesh.position.x = (wingWidth / 2) * data.side; wingPivotGroup.add(wingMesh); const wingZRotation = wingAngleRad * data.vertical; wingPivotGroup.rotation.set(0, data.ry, wingZRotation); aircraftGroup.add(wingPivotGroup); const cannonLocalOffset = new THREE.Vector3(wingWidth * data.side, 0, -0.2); cannonLocalOffset.applyEuler(wingPivotGroup.rotation); const cannonFinalPosition = wingPivotGroup.position.clone().add(cannonLocalOffset); aircraftGroup.userData.cannonOffsets.push(cannonFinalPosition); const markGeo = new THREE.BoxGeometry(1, wingThickness + 0.05, 0.5); const markMesh = new THREE.Mesh(markGeo, redMat); const markLocalPos = new THREE.Vector3((wingWidth * 0.8) * data.side, 0, 0); markMesh.position.copy(markLocalPos); wingPivotGroup.add(markMesh); }); aircraftGroup.scale.set(0.8, 0.8, 0.8); aircraftGroup.userData.boundingSphere = playerBoundingSphere; return aircraftGroup;
        }
        function createStarDestroyer() {
            const destroyerGroup = new THREE.Group(); destroyerGroup.position.set(0, 100, 1800); const length = 700; const width = 350; const height = 90; const hullMaterial = new THREE.MeshStandardMaterial({ color: 0x666677, roughness: 0.7, metalness: 0.2 }); const detailMaterial = new THREE.MeshStandardMaterial({ color: 0x555566, roughness: 0.8 }); const shape = new THREE.Shape(); shape.moveTo(0, -width / 2); shape.lineTo(length, 0); shape.lineTo(0, width / 2); shape.closePath(); const extrudeSettings = { steps: 1, depth: height, bevelEnabled: false }; const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings); geometry.center(); geometry.rotateX(-Math.PI / 2); const hull = new THREE.Mesh(geometry, hullMaterial); destroyerGroup.add(hull); const bridgeWidth = 50; const bridgeHeight = 40; const bridgeDepth = 65; const bridgeGeo = new THREE.BoxGeometry(bridgeWidth, bridgeHeight, bridgeDepth); const bridge = new THREE.Mesh(bridgeGeo, detailMaterial); bridge.position.set(length * 0.1, height / 2 + bridgeHeight / 2, 0); destroyerGroup.add(bridge); const numGreebles = 100; const greebleBaseSize = 5; for (let i = 0; i < numGreebles; i++) { const greebleSize = greebleBaseSize * (Math.random() * 0.5 + 0.75); const greebleHeight = greebleSize * (Math.random() * 1.5 + 0.5); const greebleGeo = new THREE.BoxGeometry(greebleSize, greebleHeight , greebleSize); const greeble = new THREE.Mesh(greebleGeo, detailMaterial); const side = Math.random() < 0.5 ? 1 : -1; const surfaceY = side * (height / 2 + greebleHeight / 2); const randX = (Math.random() * 0.9 + 0.05) * length; const maxZ = (width / 2) * (1 - randX / length) * 0.9; const randZ = (Math.random() - 0.5) * 2 * maxZ; greeble.position.set(randX - (length/2), surfaceY, randZ); greeble.rotation.y = Math.random() * Math.PI; destroyerGroup.add(greeble); } destroyerGroup.userData = { type: 'destroyer', isDestructible: true, destroyerHits: 0, cannons: [], boundingBox: new THREE.Box3() }; const cannonPositions = [ { x: length*0.4, y: height/2, z: width*0.1 },{ x: length*0.4, y: height/2, z: -width*0.1 },{ x: length*0.6, y: height/2, z: width*0.2 },{ x: length*0.6, y: height/2, z: -width*0.2 },{ x: length*0.8, y: height/2, z: width*0.1 },{ x: length*0.8, y: height/2, z: -width*0.1 },{ x: length*0.2, y: height/2, z: width*0.15 },{ x: length*0.2, y: height/2, z: -width*0.15 },{ x: length*0.5, y: height/2, z: 0 },{ x: length*0.7, y: height/2, z: 0 },{ x: length*0.4, y: -height/2, z: width*0.1 },{ x: length*0.4, y: -height/2, z: -width*0.1 },{ x: length*0.6, y: -height/2, z: width*0.2 },{ x: length*0.6, y: -height/2, z: -width*0.2 },{ x: length*0.8, y: -height/2, z: width*0.1 },{ x: length*0.8, y: -height/2, z: -width*0.1 },{ x: length*0.2, y: -height/2, z: width*0.15 },{ x: length*0.2, y: -height/2, z: -width*0.15 },{ x: length*0.5, y: -height/2, z: 0 },{ x: length*0.7, y: -height/2, z: 0 } ]; cannonPositions.forEach((pos, index) => { const adjustedX = pos.x - (length/2); const cannon = createDestroyerCannon(destroyerGroup); const surfaceOffset = (pos.y > 0 ? 2 : -2); cannon.position.set(adjustedX, pos.y + surfaceOffset , pos.z); const aimTarget = destroyerGroup.position.clone().add(new THREE.Vector3(adjustedX * 1.1, pos.y, pos.z * 1.1)); cannon.lookAt(aimTarget); destroyerGroup.add(cannon); destroyerGroup.userData.cannons.push(cannon); }); destroyerGroup.updateMatrixWorld(true); destroyerGroup.userData.boundingBox.setFromObject(destroyerGroup, true); console.log("Destroyer BB:", destroyerGroup.userData.boundingBox.getSize(new THREE.Vector3())); return destroyerGroup;
        }
        function createDestroyerCannon(parentDestroyer) {
            const cannonLength = 12; const cannonRadius = 2.5; const geo = new THREE.CylinderGeometry(cannonRadius, cannonRadius * 0.8, cannonLength, 8); const mat = new THREE.MeshStandardMaterial({ color: 0x444455, roughness: 0.6 }); const cannon = new THREE.Mesh(geo, mat); cannon.geometry.rotateX(Math.PI / 2); cannon.userData = { type: 'destroyerCannon', isDestructible: true, hp: DESTROYER_CANNON_HP, fireRate: ENEMY_CANNON_FIRE_RATE + (Math.random() - 0.5) * 0.5, lastShotTime: 0, range: ENEMY_CANNON_RANGE, accuracy: ENEMY_HIT_CHANCE,
